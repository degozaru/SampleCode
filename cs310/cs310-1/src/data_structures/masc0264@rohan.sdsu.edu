package data_structures;

import java.util.Iterator;
import java.util.NoSuchElementException;

public class OrderedVector<E> implements OrderedListADT {
  //Variable Declarations
  private int size, maxSize;
  private E[] vectorArray = (E[])new Object[DEFAULT_MAX_CAPACITY];

  //Constructor
  public OrderedVector() {
    size = 0;
    maxSize = DEFAULT_MAX_CAPACITY;
  } //End constructor

  //This will insert the object into the array. it will be organized accordingly.
	public void insert(E obj) {
    size++;
    
    //If the array grows too large, this will create a new array and repopulate it.
    if(size>maxSize) {
      maxSize *= 2;
      E[] temp = (E[])new Object[maxSize];
      for(int i=0; i<size; i++) temp[i] = vectorArray[i];
      vectorArray = temp;
    }

    //Find the insertion location and shift the objects accordingly. Inserts the object.
    int insertLoc = find(obj, 0, size-1);
    for(int i=insertLoc; i<size-1; i++) vectorArray[i+1] = vectorArray[i];
    vectorArray[insertLoc] = obj;
	} //End insert()

  //Pops the element from the array and adjusts the array accordingly
	public E remove(int index) {
    //This will throw an exception if an out of bounds operation is attempted
    if(index<0 || index>=size) throw new IndexOutOfBoundsException("Out of Bounds");

    //This will put the object in a temp array and update the size.
    E tempObj = vectorArray[index];
    size--;
    
    //If the array is less than 25% populated, a resize will resize the array.
    if(maxSize/4 > size) {
      maxSize /= 2;
      E[] temp = (E[])new Object[maxSize];
      for(int i=0; i<size; i++) temp[i] = vectorArray[i];
      vectorArray = temp;
    }

    for(; index<size; index++) vectorArray[index] = vectorArray[index+1];
    return tempObj;
	} //End remove()

  //Removes and returns the parameter object if it contains it, null otherwise
	public E remove(E obj) {
    try {return remove(binSearch(obj, 0, size-1));}
    catch(Exception e){return null;}
	} //End remove()

  //Returns the parameter object located at the parameter
  //Throws OutOfBoundsException if the index provided is outside the array range.
	public E get(int index) {
    if(index<0 || index>=size) throw new IndexOutOfBoundsException("Out of Bounds");
    return vectorArray[index];
	} //End get()

  //Returns the object if it exists inside the array, null if not.
	public E get(E obj) {
    return contains(obj)?obj : null;
	} //End get()

  //Returns true if the parameter object is in the list, false otherwise.
	public boolean contains(E obj) {
    return binSearch(obj, 0, size-1) != -1;
	} //End contains()

  //The list is returned to an empty state.
	public void clear() {
    vectorArray = (E[])new Object[DEFAULT_MAX_CAPACITY];
    size = 0;
    maxSize = DEFAULT_MAX_CAPACITY;
	} //End clear()

  //Returns true if the array is empty
	public boolean isEmpty() {
    return size==0;
	} //End isEmpty()

  //Returns the number of objects currently in the array.
	public int size() {
		return size;
	} //End size()

	//Returns an iterator of the values in the list,
  //presented in the same order as the list
	public Iterator iterator() {
    return new IteratorHelper();
	}

  //This function will return the index of where the element is located
  //returns -1 if not found
  private int binSearch(E obj,int low, int hi) {
    //Termination condition: checked the array and could not find it
    if(hi<low) return -1;

    //Compare the middle of the array to the sought object
    int mid = (low+hi)/2;
    int comp = ((Comparable<E>)obj).compareTo(vectorArray[mid]);
    if(comp==0) return mid;

    //If not found, recursively call the function with a refined search area.
    return (comp>0)?binSearch(obj, low, mid-1) : binSearch(obj, mid+1, hi);
  } //End binSearch()

  //This function will look for the element and return the point where it should be inserted.
  //If not found, the function will return the last index it checked.
  private int find(E obj, int low, int hi) {
    //Termination condition: checked the array and could not find it.
    if(hi<low) return -1;

    //Compare the middle of the array to the sought object
    int mid = (low+hi)/2;
    int comp = ((Comparable<E>)obj).compareTo(vectorArray[mid]);
    if(comp==0) return mid;

    //If not found, recursively call the function with a refined search area.
    int flag = (comp>0)?binSearch(obj, low, mid-1) : binSearch(obj, mid+1, hi);

    //If the call after this turns up to terminate, return the last index searched.
    return (flag==-1)?mid : flag;
  } //End find()

  //This class will help with iteration, and provide the iterator function.
  class IteratorHelper implements Iterator<E> {
    int iterIndex;
    
    public IteratorHelper() {
      iterIndex = 0;
    }
        
    public boolean hasNext() {
      return iterIndex < size;
    }
        
    public E next() {
      if(!hasNext()) throw new NoSuchElementException();
      return vectorArray[iterIndex++];
    }
        
    public void remove() {
      throw new UnsupportedOperationException();
    }
  }
} //End OrderVector()
